Got it. What you’re describing is basically a ledger + attribution system: every dollar that enters the platform gets recorded once (source + metadata), then split into creator/platform shares according to the split rule for that revenue type, then rolled up by month for the admin dashboard, and drilled down into an invoice-style detail view per creator.

Below is a clean blueprint (DB schema + rules + APIs + admin UI behavior) that will scale across subscriptions, rooms, tips, gifts, competitions, and future revenue types without rewriting everything.

1) Core principle: immutable revenue ledger (single source of truth)
You need 2 layers:

Revenue Event (what happened)

Revenue Split Entries (who gets what from that event)

This avoids “recalculating” earnings later and makes audits/refunds easy.

2) Database schema (Postgres)
A) Revenue configuration

revenue_types

id (pk)

code (unique) — subscription, tip, gift, room_unlock, competition_entry, ppv_message, etc.

name

description

is_active

split_profiles (your “5 split rules” live here)

id (pk)

name — e.g. Standard 85/15, Promo 100/0, Competition 90/10, etc.

creator_pct numeric(5,2)

platform_pct numeric(5,2)

processing_pct numeric(5,2) default 0 (optional)

affiliate_pct numeric(5,2) default 0 (optional)

other_pct numeric(5,2) default 0 (optional)

effective_from timestamptz

effective_to timestamptz nullable

constraint: total_pct = 100.00

revenue_type_split_map

id (pk)

revenue_type_id (fk)

room_key nullable — e.g. truth_or_dare, confessions, etc. (or room_id)

split_profile_id (fk)

effective_from, effective_to

This lets you say:

Tips in any room = 100% creator

Subscriptions = 85/15

Competition entries = 90/10

Flashdrop unlocks = 80/20
…and change it over time without breaking history.

B) Money in: events + attribution

revenue_events (immutable “money came in” record)

id (pk, uuid)

created_at timestamptz

occurred_at timestamptz (when the fan action happened)

fan_user_id (fk users)

creator_user_id (fk users) nullable (some purchases may not be creator-bound; most are)

revenue_type_id (fk)

room_id nullable (fk rooms)

competition_id nullable

subscription_id nullable

currency (e.g. USD, CAD)

gross_amount numeric(12,2) (what fan paid)

net_amount numeric(12,2) (after processor fee, if you want)

payment_provider (stripe, etc.)

payment_intent_id / charge_id (unique)

status enum: succeeded | pending | failed | refunded | disputed | reversed

metadata jsonb (message id, gift sku, etc.)

Indexes you’ll need

(creator_user_id, occurred_at)

(status, occurred_at)

(revenue_type_id, occurred_at)

unique (payment_provider, payment_intent_id) to prevent double credits

C) Splits: who earned what

revenue_splits

id (pk)

revenue_event_id (fk)

beneficiary_type enum: creator | platform | processor | affiliate | other

beneficiary_id nullable (creator id for creator rows; null for platform)

split_profile_id (fk) (the rule used)

pct numeric(5,2)

amount numeric(12,2) (calculated from gross or net — pick one and be consistent)

created_at timestamptz

This table is the “accounting ledger” you will sum for dashboards/invoices.

D) Time spent per activity (session tracking)

You asked: “track each activity date and time spent separately”.

Do this as a separate table linked to the revenue event (not all events have time).

creator_activity_sessions

id (pk)

creator_user_id (fk)

room_id nullable

session_type enum: live_room | competition | messaging | other

started_at timestamptz

ended_at timestamptz nullable

duration_seconds int (store computed on close)

hosted_by_creator bool

metadata jsonb

Then link revenue events to sessions:

revenue_event_sessions

revenue_event_id (fk)

session_id (fk)

Now the invoice can show spent time next to each earning line.

E) Monthly rollups (fast dashboard)

You can compute totals on the fly from revenue_splits, but dashboards get slow.

Create a monthly snapshot table you can rebuild:

creator_monthly_earnings

id (pk)

creator_user_id

year int

month int

creator_gross numeric(12,2)

creator_net numeric(12,2) (after split)

platform_net numeric(12,2)

events_count int

last_calculated_at timestamptz

And/or build as a materialized view refreshed by cron/worker.

Important requirement you stated:

“Total in the photo must always total the creators earning so far in that month.”

So your Admin “Creator Payouts” top number should be:

SUM(revenue_splits.amount WHERE beneficiary_type='creator' AND occurred_at within month AND status='succeeded')

Refunds/disputes should create negative adjustments (see below).

3) Refunds, disputes, chargebacks (must be accounted)

When a payment is refunded:

update revenue_events.status = refunded

insert reversal revenue_event OR insert negative split adjustments

Best practice: create an adjustment event:

revenue_type = adjustment_refund

gross_amount = -original_gross

splits mirrored negative

This keeps ledger consistent and invoices correct.

4) Split calculation rules (your “5 split”)

When a revenue_event is created (and payment is confirmed):

Determine applicable split_profile_id using:

revenue_type

room or competition context

effective date range

Compute each beneficiary amount:

amount = round(base_amount * pct/100, 2)

Handle rounding remainder:

add remainder to creator or platform consistently (choose one; I recommend platform for accounting stability, or creator for goodwill—just be consistent)

Insert rows into revenue_splits

Base amount: pick one

gross-based splits (simpler, common in creator platforms)

or net-after-processor splits (more “accounting accurate”)

5) Admin panel UI behavior (matching what you want)
A) Creator Payouts dashboard table (your screenshot area)

Columns:

Creator (clickable)

Gross (month-to-date)

Creator Earned (month-to-date after split)

Platform Earned (month-to-date)

Events (#)

Last Activity

Status (Ready / On Hold / Paid Partial / Paid)

Top summary card:

Total Creators Earned (MTD) = sum of creator splits this month

Optional: Platform Earned (MTD)

Filters:

Month selector (default current month)

Status filter (succeeded/refunded/disputed)

Revenue type filter (subscriptions/tips/rooms/competitions)

Creator search

B) Click creator → “Invoice Drawer / Invoice Page”

Show:

Header:

Creator name + handle

Month range

Total Gross

Total Creator Earnings

Total Platform Earnings

Total Duration (sum sessions) optional

Line item table (every revenue event):

Date

Time

Room / Category

Type (Tip/Gift/Subscription/Unlock/Competition)

Fan (who paid) + user id

Session time spent (duration)

Amount collected (gross)

Split profile used (e.g. 85/15)

Creator share

Platform share

Status

Actions (you requested):

View (default)

Print (print-friendly invoice view)

Email (send invoice PDF or link)

Edit (admin-only adjustments/notes)

Optional: Export CSV

Also include:

Notes / flags: “KYC pending”, “hold payouts”, “manual review”, etc.

6) APIs you’ll need (backend)
Revenue ingestion (from payments)

POST /api/revenue/record

called by your payment webhook handler after confirmed payment

creates revenue_event + revenue_splits + optional session link

Admin payouts list

GET /api/admin/payouts?year=2026&month=2&search=&sort=...

returns creators with month totals from splits (or monthly snapshot)

Creator invoice detail

GET /api/admin/payouts/:creatorId/invoice?year=2026&month=2

returns:

summary totals

line items (events joined to splits + fan + room + session duration)

Admin actions

POST /api/admin/payouts/:creatorId/email-invoice

GET /api/admin/payouts/:creatorId/invoice.pdf

POST /api/admin/payouts/:creatorId/adjustment

creates an adjustment event (positive/negative) with splits

POST /api/admin/payouts/:creatorId/mark-paid

creates a payout batch entry (below)

Payout batches (optional but recommended)

payout_batches

id, period_year, period_month, created_at, status
payout_batch_items

batch_id, creator_user_id, amount, status, paid_at, reference

This separates “earnings” from “money paid out”.

7) What I need from you (but I’ll still keep moving even if you don’t answer)

To lock the logic precisely, you only need to define:

Your 5 split profiles (the exact % breakdowns and when they apply)

Whether splits are on gross or net-after-fees

Which actions count as “time spent” and how you define a session end

If you paste your current backend stack structure (tables you already have for rooms/subscriptions/tips), I can map this onto your existing schema without breaking anything and outline exact migrations + endpoints names to match your codebase.

Show me a png mock up how this would look
Image created
•
Creator payouts dashboard overview
Share
send me full plan and full code to give developer for this page

Below is a complete, developer-ready plan + full starter code (DB migrations + backend APIs + admin UI page + invoice drawer + print/email hooks) for PlayGroundX → Admin → Creator Payouts exactly like you described.

I wrote it so you can drop it into a typical Node/Express/TypeScript + Postgres + React stack. If your repo is slightly different (Next.js, Prisma, etc.), your dev can still map it 1:1 because the data model + endpoints are clean.

1) Full plan (what to build)
A) What the page must do
Admin “Creator Payouts” page

Shows month-to-date totals:

Total Creators Earned (MTD) = sum of all creator split entries for selected month

(optional) Platform earned MTD

Table of creators who earned in that month:

Creator (clickable)

Gross collected

Creator earned (after split)

Platform earned

Events count

Last activity

Status (Ready / Hold / Paid)

Filters:

Month picker

Revenue type

Status

Search creators

Sort (recommended = Creator earned desc)

Click creator → expands invoice detail (drawer/modal/page)

Shows invoice summary for that creator for the month

Shows line items:

Date, time

Room / category

Type (tip/gift/subscription/unlock/competition)

Fan (who paid)

Session duration / time spent (linked session)

Amount collected

Split profile used

Creator share

Platform share

Status

Actions:

View

Print

Email

Edit (admin adjustments)

B) Core accounting rules (must not break)

Every payment becomes one immutable revenue_event

Splits are saved as rows in revenue_splits (creator + platform + other parts)

Refunds/disputes create adjustment events (negative values) so totals stay correct.

No front-end local storage gating: all admin access and profile/role checks come from server.

2) Database (Postgres) – SQL migrations

Put these in a migration file (e.g., migrations/2026_02_09_creator_payouts.sql).

-- =========================
  payment_provider TEXT NOT NULL,
  payment_intent_id TEXT NOT NULL,
  status revenue_event_status NOT NULL DEFAULT 'pending',
  metadata JSONB NOT NULL DEFAULT '{}'::jsonb,
  CONSTRAINT uq_payment UNIQUE (payment_provider, payment_intent_id)
);


CREATE INDEX IF NOT EXISTS idx_revenue_events_creator_time
ON revenue_events (creator_user_id, occurred_at);


CREATE INDEX IF NOT EXISTS idx_revenue_events_status_time
ON revenue_events (status, occurred_at);


-- =========================
-- 4) SPLITS (WHO GETS WHAT)
-- =========================
CREATE TABLE IF NOT EXISTS revenue_splits (
  id BIGSERIAL PRIMARY KEY,
  revenue_event_id UUID NOT NULL REFERENCES revenue_events(id) ON DELETE CASCADE,
  beneficiary_type split_beneficiary_type NOT NULL,
  beneficiary_id UUID, -- creator id when beneficiary_type='creator'
  split_profile_id BIGINT NOT NULL REFERENCES split_profiles(id) ON DELETE RESTRICT,
  pct NUMERIC(5,2) NOT NULL,
  amount NUMERIC(12,2) NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);


CREATE INDEX IF NOT EXISTS idx_revenue_splits_event
ON revenue_splits (revenue_event_id);


CREATE INDEX IF NOT EXISTS idx_revenue_splits_creator
ON revenue_splits (beneficiary_type, beneficiary_id);


-- =========================
-- 5) SESSION TRACKING (TIME SPENT)
-- =========================
CREATE TABLE IF NOT EXISTS creator_activity_sessions (
  id UUID PRIMARY KEY,
  creator_user_id UUID NOT NULL,
  room_key TEXT,
  session_type session_type NOT NULL,
  started_at TIMESTAMPTZ NOT NULL,
  ended_at TIMESTAMPTZ,
  duration_seconds INT,
  metadata JSONB NOT NULL DEFAULT '{}'::jsonb
);


CREATE INDEX IF NOT EXISTS idx_sessions_creator_time
ON creator_activity_sessions (creator_user_id, started_at);


CREATE TABLE IF NOT EXISTS revenue_event_sessions (
  revenue_event_id UUID NOT NULL REFERENCES revenue_events(id) ON DELETE CASCADE,
  session_id UUID NOT NULL REFERENCES creator_activity_sessions(id) ON DELETE CASCADE,
  PRIMARY KEY (revenue_event_id, session_id)
);


-- =========================
-- 6) PAYOUT BATCHES (PAYING OUT IS SEPARATE FROM EARNING)
-- =========================
CREATE TABLE IF NOT EXISTS payout_batches (
  id UUID PRIMARY KEY,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  period_year INT NOT NULL,
  period_month INT NOT NULL,
  status TEXT NOT NULL DEFAULT 'open',
  metadata JSONB NOT NULL DEFAULT '{}'::jsonb
);


CREATE TABLE IF NOT EXISTS payout_batch_items (
  id UUID PRIMARY KEY,
  batch_id UUID NOT NULL REFERENCES payout_batches(id) ON DELETE CASCADE,
  creator_user_id UUID NOT NULL,
  amount NUMERIC(12,2) NOT NULL,
  status payout_item_status NOT NULL DEFAULT 'ready',
  paid_at TIMESTAMPTZ,
  reference TEXT,
  metadata JSONB NOT NULL DEFAULT '{}'::jsonb,
  CONSTRAINT uq_batch_creator UNIQUE (batch_id, creator_user_id)
);
Seed (example)
INSERT INTO revenue_types (code, name) VALUES
('subscription','Subscription'),
('tip','Tip'),
('gift','Gift'),
('room_unlock','Room Unlock'),
('competition_entry','Competition Entry'),
('adjustment','Adjustment')
ON CONFLICT DO NOTHING;


INSERT INTO split_profiles (name, creator_pct, platform_pct, processing_pct, affiliate_pct, other_pct)
VALUES
('Standard 85/15', 85, 15, 0, 0, 0),
('Creator 100%', 100, 0, 0, 0, 0),
('Competition 90/10', 90, 10, 0, 0, 0)
ON CONFLICT DO NOTHING;
3) Backend (Node/Express/TypeScript)
A) Folder layout
backend/
  src/
    db/
      pool.ts
      sql.ts
    middleware/
      requireAdmin.ts
    services/
      splitEngine.ts
      payoutsService.ts
      invoiceService.ts
    routes/
      adminPayoutsRoutes.ts
      revenueIngestRoutes.ts
    server.ts
B) DB pool
// src/db/pool.ts
import { Pool } from "pg";


export const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  ssl: process.env.PGSSLMODE ? { rejectUnauthorized: false } : undefined,
});
C) Admin auth middleware (server-side only)
// src/middleware/requireAdmin.ts
import { Request, Response, NextFunction } from "express";


/**
 * Assumes you already have auth middleware that sets req.user.
 * Must be server-validated. NO localStorage gating.
 */
export function requireAdmin(req: Request, res: Response, next: NextFunction) {
  const user = (req as any).user;
  if (!user) return res.status(401).json({ error: "Unauthorized" });
  if (user.role !== "admin" && user.role !== "superadmin") {
    return res.status(403).json({ error: "Forbidden" });
  }
  next();
}
D) Split Engine (5-way split with rounding)
// src/services/splitEngine.ts
import { pool } from "../db/pool";


export type SplitProfile = {
  id: number;
  creator_pct: number;
  platform_pct: number;
  processing_pct: number;
  affiliate_pct: number;
  other_pct: number;
};


function round2(n: number) {
  return Math.round((n + Number.EPSILON) * 100) / 100;
}


export async function getSplitProfileForEvent(params: {
  revenueTypeId: number;
  roomKey?: string | null;
  occurredAt: Date;
}): Promise<SplitProfile> {
  const { revenueTypeId, roomKey, occurredAt } = params;


  // Choose most specific: revenueType + roomKey match, else revenueType only
  const q = `
    SELECT sp.*
    FROM revenue_type_split_map m
    JOIN split_profiles sp ON sp.id = m.split_profile_id
    WHERE m.revenue_type_id = $1
      AND (m.room_key = $2 OR (m.room_key IS NULL AND $2 IS NULL) OR (m.room_key IS NULL))
      AND m.effective_from <= $3
      AND (m.effective_to IS NULL OR m.effective_to > $3)
    ORDER BY (m.room_key IS NOT NULL) DESC, m.effective_from DESC
    LIMIT 1
  `;
  const r = await pool.query(q, [revenueTypeId, roomKey ?? null, occurredAt]);
  if (r.rowCount === 0) {
    throw new Error(`No split profile found for revenue_type_id=${revenueTypeId}, roomKey=${roomKey}`);
  }
  return r.rows[0];
}


export function computeSplits(baseAmount: number, profile: SplitProfile) {
  const parts = [
    { key: "creator", pct: profile.creator_pct },
    { key: "platform", pct: profile.platform_pct },
    { key: "processor", pct: profile.processing_pct },
    { key: "affiliate", pct: profile.affiliate_pct },
    { key: "other", pct: profile.other_pct },
  ].filter(p => p.pct > 0);


  const amounts = parts.map(p => ({
    ...p,
    amount: round2(baseAmount * (p.pct / 100)),
  }));


  // Remainder handling (from rounding): add to platform by default
  const sum = round2(amounts.reduce((a, b) => a + b.amount, 0));
  const remainder = round2(baseAmount - sum);
  if (remainder !== 0) {
    const platform = amounts.find(a => a.key === "platform") ?? amounts[0];
    platform.amount = round2(platform.amount + remainder);
  }


  return amounts;
}
E) Revenue ingestion (called by Stripe webhook handler or internal payment confirmation)
// src/routes/revenueIngestRoutes.ts
    paymentProvider,
    paymentIntentId,
    status,
    sessionId,
    metadata,
  } = req.body;


  const eventId = uuidv4();
  const occurred = new Date(occurredAt);


  const client = await pool.connect();
  try {
    await client.query("BEGIN");


    // Insert revenue event (prevents duplicate credit via unique constraint)
    const insertEvent = `
      INSERT INTO revenue_events (
        id, occurred_at, fan_user_id, creator_user_id, revenue_type_id,
        room_key, competition_id, subscription_id, currency,
        gross_amount, net_amount, payment_provider, payment_intent_id, status, metadata
      )
      VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15)
      RETURNING *
    `;
    const eventRow = await client.query(insertEvent, [
      eventId,
      occurred,
      fanUserId,
      creatorUserId ?? null,
      revenueTypeId,
      roomKey ?? null,
      competitionId ?? null,
      subscriptionId ?? null,
      currency ?? "USD",
      grossAmount,
      netAmount ?? null,
      paymentProvider,
      paymentIntentId,
      status ?? "succeeded",
      metadata ?? {},
    ]);


    const event = eventRow.rows[0];


    // Determine split profile and compute splits
    const profile = await getSplitProfileForEvent({
      revenueTypeId,
      roomKey: roomKey ?? null,
      occurredAt: occurred,
    });


    // Choose base: gross by default (change to net if you prefer)
    const baseAmount = Number(event.gross_amount);
    const splitAmounts = computeSplits(baseAmount, profile);


    // Insert splits
    for (const s of splitAmounts) {
      const beneficiaryType = s.key; // creator/platform/processor/affiliate/other
      const beneficiaryId = beneficiaryType === "creator" ? creatorUserId : null;


      await client.query(
        `INSERT INTO revenue_splits
         (revenue_event_id, beneficiary_type, beneficiary_id, split_profile_id, pct, amount)
         VALUES ($1,$2,$3,$4,$5,$6)`,
        [eventId, beneficiaryType, beneficiaryId, profile.id, s.pct, s.amount]
      );
    }


    // Optional: link event to a session for time spent
    if (sessionId) {
      await client.query(
        `INSERT INTO revenue_event_sessions (revenue_event_id, session_id)
         VALUES ($1,$2) ON CONFLICT DO NOTHING`,
        [eventId, sessionId]
      );
    }


    await client.query("COMMIT");
    res.json({ ok: true, eventId });
  } catch (e: any) {
    await client.query("ROLLBACK");
    // If unique violation on payment intent, return idempotent response
    if (String(e?.code) === "23505") return res.status(409).json({ ok: false, error: "Duplicate payment_intent_id" });
    res.status(500).json({ ok: false, error: e.message });
  } finally {
    client.release();
  }
});
F) Admin payouts APIs (list + invoice + actions)
1) List creators for a month
// src/services/payoutsService.ts
import { pool } from "../db/pool";


export async function getPayoutsMonth(params: {
  year: number;
  month: number; // 1-12
  search?: string;
  revenueTypeCode?: string;
  status?: string; // succeeded/refunded/etc
  sort?: "creatorEarnedDesc" | "creatorEarnedAsc" | "lastActivityDesc";
}) {
  const { year, month, search, revenueTypeCode, status, sort } = params;


  const start = new Date(Date.UTC(year, month - 1, 1, 0, 0, 0));
  const end = new Date(Date.UTC(year, month, 1, 0, 0, 0));


  const orderBy =
    sort === "creatorEarnedAsc" ? "creator_earned ASC" :
    sort === "lastActivityDesc" ? "last_activity DESC NULLS LAST" :
    "creator_earned DESC";


  // Assumes you have users table with id, username, display_name, avatar_url
  const q = `
    WITH filtered_events AS (
      SELECT e.*
      FROM revenue_events e
      JOIN revenue_types rt ON rt.id = e.revenue_type_id
      WHERE e.occurred_at >= $1 AND e.occurred_at < $2
        AND ($3::text IS NULL OR e.status = $3::revenue_event_status)
        AND ($4::text IS NULL OR rt.code = $4)
    ),
    creator_sums AS (
      SELECT
        e.creator_user_id AS creator_id,
        SUM(CASE WHEN e.status='succeeded' THEN e.gross_amount ELSE 0 END) AS gross_collected,
        SUM(CASE WHEN s.beneficiary_type='creator' THEN s.amount ELSE 0 END) AS creator_earned,
        SUM(CASE WHEN s.beneficiary_type='platform' THEN s.amount ELSE 0 END) AS platform_earned,
        COUNT(DISTINCT e.id) AS events_count,
        MAX(e.occurred_at) AS last_activity
      FROM filtered_events e
      JOIN revenue_splits s ON s.revenue_event_id = e.id
      WHERE e.creator_user_id IS NOT NULL
      GROUP BY e.creator_user_id
    )
    SELECT
      u.id AS creator_id,
      u.username,
      u.display_name,
      u.avatar_url,
      cs.gross_collected,
      cs.creator_earned,
      cs.platform_earned,
      cs.events_count,
      cs.last_activity,
      'Ready' AS status
    FROM creator_sums cs
    JOIN users u ON u.id = cs.creator_id
    WHERE ($5::text IS NULL OR (u.username ILIKE '%'||$5||'%' OR u.display_name ILIKE '%'||$5||'%'))
    ORDER BY ${orderBy}
  `;


  const r = await pool.query(q, [
    start.toISOString(),
    end.toISOString(),
    status ?? null,
    revenueTypeCode ?? null,
    search ?? null
  ]);


  const totalsQ = `
    SELECT
      COALESCE(SUM(s.amount),0)::numeric(12,2) AS total_creators_earned,
      COALESCE(SUM(CASE WHEN s.beneficiary_type='platform' THEN s.amount ELSE 0 END),0)::numeric(12,2) AS total_platform_earned
    FROM revenue_events e
    JOIN revenue_splits s ON s.revenue_event_id = e.id
    WHERE e.occurred_at >= $1 AND e.occurred_at < $2
      AND e.status='succeeded'
      AND s.beneficiary_type IN ('creator','platform')
  `;
  const totals = await pool.query(totalsQ, [start.toISOString(), end.toISOString()]);


  return { rows: r.rows, totals: totals.rows[0] };
}
2) Invoice detail for one creator
// src/services/invoiceService.ts
import { pool } from "../db/pool";


export async function getCreatorInvoice(params: {
  creatorId: string;
  year: number;
  month: number;
}) {
  const { creatorId, year, month } = params;
  const start = new Date(Date.UTC(year, month - 1, 1, 0, 0, 0));
  const end = new Date(Date.UTC(year, month, 1, 0, 0, 0));


  const summaryQ = `
    SELECT
      COALESCE(SUM(e.gross_amount),0)::numeric(12,2) AS gross_collected,
      COALESCE(SUM(CASE WHEN s.beneficiary_type='creator' THEN s.amount ELSE 0 END),0)::numeric(12,2) AS creator_earned,
      COALESCE(SUM(CASE WHEN s.beneficiary_type='platform' THEN s.amount ELSE 0 END),0)::numeric(12,2) AS platform_earned,
      COUNT(DISTINCT e.id) AS events_count,
      MAX(e.occurred_at) AS last_activity
    FROM revenue_events e
    JOIN revenue_splits s ON s.revenue_event_id = e.id
    WHERE e.creator_user_id = $1
      AND e.occurred_at >= $2 AND e.occurred_at < $3
  `;
  const summaryR = await pool.query(summaryQ, [creatorId, start.toISOString(), end.toISOString()]);


  const linesQ = `
    SELECT
      e.id AS event_id,
      e.occurred_at,
      rt.code AS revenue_type,
      e.room_key,
      e.currency,
      e.gross_amount,
      e.status,
      e.metadata,
      fu.id AS fan_id,
      fu.username AS fan_username,
      fu.display_name AS fan_display_name,
      sp.name AS split_name,
      COALESCE(sess.duration_seconds,0) AS duration_seconds,
      -- creator share + platform share per event
      COALESCE(SUM(CASE WHEN s.beneficiary_type='creator' THEN s.amount ELSE 0 END),0)::numeric(12,2) AS creator_share,
      COALESCE(SUM(CASE WHEN s.beneficiary_type='platform' THEN s.amount ELSE 0 END),0)::numeric(12,2) AS platform_share
    FROM revenue_events e
    JOIN revenue_types rt ON rt.id = e.revenue_type_id
    JOIN revenue_splits s ON s.revenue_event_id = e.id
    JOIN split_profiles sp ON sp.id = s.split_profile_id
    JOIN users fu ON fu.id = e.fan_user_id
    LEFT JOIN revenue_event_sessions res ON res.revenue_event_id = e.id
    LEFT JOIN creator_activity_sessions sess ON sess.id = res.session_id
    WHERE e.creator_user_id = $1
      AND e.occurred_at >= $2 AND e.occurred_at < $3
    GROUP BY
      e.id, e.occurred_at, rt.code, e.room_key, e.currency, e.gross_amount, e.status, e.metadata,
      fu.id, fu.username, fu.display_name, sp.name, sess.duration_seconds
    ORDER BY e.occurred_at DESC
  `;
  const linesR = await pool.query(linesQ, [creatorId, start.toISOString(), end.toISOString()]);


  return { summary: summaryR.rows[0], lines: linesR.rows };
}
3) Routes
// src/routes/adminPayoutsRoutes.ts
import { Router } from "express";
import { requireAdmin } from "../middleware/requireAdmin";
import { getPayoutsMonth } from "../services/payoutsService";
import { getCreatorInvoice } from "../services/invoiceService";


export const adminPayoutsRoutes = Router();
adminPayoutsRoutes.use(requireAdmin);


adminPayoutsRoutes.get("/payouts", async (req, res) => {
  const year = Number(req.query.year);
  const month = Number(req.query.month);
  const search = (req.query.search as string) || undefined;
  const revenueTypeCode = (req.query.revenueType as string) || undefined;
  const status = (req.query.status as string) || undefined;
  const sort = (req.query.sort as any) || "creatorEarnedDesc";


  const data = await getPayoutsMonth({ year, month, search, revenueTypeCode, status, sort });
  res.json(data);
});


adminPayoutsRoutes.get("/payouts/:creatorId/invoice", async (req, res) => {
  const creatorId = req.params.creatorId;
  const year = Number(req.query.year);
  const month = Number(req.query.month);


  const data = await getCreatorInvoice({ creatorId, year, month });
  res.json(data);
});


/**
 * Hooks for actions (you’ll wire real implementations)
 */
adminPayoutsRoutes.post("/payouts/:creatorId/email-invoice", async (req, res) => {
  // generate invoice PDF OR use HTML invoice template + send
  res.json({ ok: true });
});


adminPayoutsRoutes.get("/payouts/:creatorId/invoice.pdf", async (req, res) => {
  // generate PDF and stream it
  res.status(501).send("Not implemented yet");
});


adminPayoutsRoutes.post("/payouts/:creatorId/adjustment", async (req, res) => {
  // create a negative/positive adjustment revenue_event with splits
  res.status(501).json({ ok: false, error: "Not implemented yet" });
});
4) Server mount
// src/server.ts
import express from "express";
import cors from "cors";
import { adminPayoutsRoutes } from "./routes/adminPayoutsRoutes";
import { revenueIngestRoutes } from "./routes/revenueIngestRoutes";


const app = express();
app.use(cors());
app.use(express.json({ limit: "2mb" }));


// Your auth middleware should set req.user before admin routes
// app.use(authMiddleware);


app.use("/api/admin", adminPayoutsRoutes);
app.use("/api/revenue", revenueIngestRoutes);


const port = process.env.PORT || 5000;
app.listen(port, () => console.log(`Server listening on ${port}`));
4) Frontend (React) – Creator Payouts page + Invoice drawer mock
A) API helper
// src/api/adminPayoutsApi.ts
export async function fetchPayouts(params: {
  year: number; month: number;
  search?: string;
  revenueType?: string;
  status?: string;
  sort?: string;
}) {
  const qs = new URLSearchParams();
  qs.set("year", String(params.year));
  qs.set("month", String(params.month));
  if (params.search) qs.set("search", params.search);
  if (params.revenueType) qs.set("revenueType", params.revenueType);
  if (params.status) qs.set("status", params.status);
  if (params.sort) qs.set("sort", params.sort);


  const r = await fetch(`/api/admin/payouts?${qs.toString()}`, { credentials: "include" });
  if (!r.ok) throw new Error(`Failed payouts: ${r.status}`);
  return r.json();
}


export async function fetchCreatorInvoice(creatorId: string, year: number, month: number) {
  const qs = new URLSearchParams({ year: String(year), month: String(month) });
  const r = await fetch(`/api/admin/payouts/${creatorId}/invoice?${qs.toString()}`, { credentials: "include" });
  if (!r.ok) throw new Error(`Failed invoice: ${r.status}`);
  return r.json();
}
B) Creator Payouts Page (UI)
// src/pages/admin/CreatorPayouts.tsx
          </div>


          <div style={{ display: "flex", gap: 10, marginTop: 12 }}>
            <button onClick={() => window.print()}>Print</button>
            <button onClick={async () => {
              await fetch(`/api/admin/payouts/${openCreator.creator_id}/email-invoice`, { method: "POST", credentials: "include" });
              alert("Invoice email queued.");
            }}>Email</button>
            <button onClick={() => alert("Edit flow: admin adjustments + notes")}>Edit</button>
          </div>


          {invoiceLoading && <div style={{ padding: 12, opacity: 0.8 }}>Loading invoice...</div>}


          {invoice && (
            <>
              {/* Summary */}
              <div style={{
                marginTop: 12,
                padding: 12,
                borderRadius: 14,
                border: "1px solid rgba(255,0,150,0.18)"
              }}>
                <div style={{ display: "grid", gridTemplateColumns: "1fr 1fr", gap: 8 }}>
                  <div style={{ opacity: 0.75 }}>Gross Collected</div>
                  <div style={{ textAlign: "right" }}>${money(invoice.summary.gross_collected)}</div>


                  <div style={{ opacity: 0.75 }}>Creator Earned</div>
                  <div style={{ textAlign: "right", fontWeight: 800, color: "#ff6bd6" }}>${money(invoice.summary.creator_earned)}</div>


                  <div style={{ opacity: 0.75 }}>Platform Earned</div>
                  <div style={{ textAlign: "right" }}>${money(invoice.summary.platform_earned)}</div>


                  <div style={{ opacity: 0.75 }}>Events</div>
                  <div style={{ textAlign: "right" }}>{invoice.summary.events_count}</div>
                </div>
              </div>


              {/* Line items */}
              <div style={{ marginTop: 14, fontWeight: 800, opacity: 0.9 }}>Activity Details</div>
              <div style={{ marginTop: 8, display: "flex", flexDirection: "column", gap: 10 }}>
                {(invoice.lines || []).map((l: any) => (
                  <div key={l.event_id} style={{
                    padding: 12,
                    borderRadius: 14,
                    border: "1px solid rgba(255,255,255,0.08)"
                  }}>
                    <div style={{ display: "flex", gap: 8, alignItems: "center" }}>
                      <div style={{ fontWeight: 800 }}>
                        {l.revenue_type.replaceAll("_", " ")} • {l.room_key || "—"}
                      </div>
                      <div style={{ marginLeft: "auto", opacity: 0.75 }}>
                        {new Date(l.occurred_at).toLocaleString()}
                      </div>
                    </div>


                    <div style={{ marginTop: 6, display: "grid", gridTemplateColumns: "1fr 1fr", gap: 8, fontSize: 13, opacity: 0.9 }}>
                      <div>Fan: <b>@{l.fan_username}</b></div>
                      <div style={{ textAlign: "right" }}>Time Spent: <b>{secondsToHms(l.duration_seconds)}</b></div>


                      <div>Split: <b>{l.split_name}</b></div>
                      <div style={{ textAlign: "right" }}>Collected: <b>${money(l.gross_amount)} {l.currency}</b></div>


                      <div>Creator Share: <b style={{ color: "#ff6bd6" }}>${money(l.creator_share)}</b></div>
                      <div style={{ textAlign: "right" }}>Platform Share: <b>${money(l.platform_share)}</b></div>


                      <div style={{ opacity: 0.75 }}>Status: {l.status}</div>
                      <div style={{ textAlign: "right", opacity: 0.75 }}>Event ID: {String(l.event_id).slice(0, 8)}…</div>
                    </div>
                  </div>
                ))}
              </div>
            </>
          )}
        </div>
      )}
    </div>
  );
}
5) Notes your developer must follow (critical)
A) Admin security (no client gating)

Every /api/admin/* endpoint must require server auth + role check.

Do NOT rely on localStorage, hidden UI, or client-side checks.

B) “Time spent” definition

Sessions should be created by room host start/stop events:

Start session when creator starts a live room / competition host

End session when they leave / stream ends

Link revenue events to sessions using revenue_event_sessions.

C) Refund/chargeback handling

Never “delete” events.

Create adjustment event (negative gross) with mirrored splits.

6) What to send your developer (copy/paste packet)

SQL migration section (tables + indexes)

Backend routes:

/api/admin/payouts

/api/admin/payouts/:creatorId/invoice

/api/revenue/record (webhook-driven)

Split Engine (getSplitProfileForEvent, computeSplits)

React page CreatorPayouts.tsx + API helper